\documentclass[11pt]{beamer}

% options
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usetheme{Boadilla}
\usecolortheme{beaver}

\lstset{ %
language=C++,                % choose the language of the code
keywordstyle=\bfseries,
basicstyle=\color{black} \small,
stringstyle=\color{red}\ttfamily, % typewriter type for strings
showspaces=false,               % show spaces adding particular underscores
showstringspaces=true,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
tabsize=2,			% sets default tabsize to 2 spaces
captionpos=b,			% sets the caption-position to bottom
breaklines=true,		% sets automatic line breaking
breakatwhitespace=false,	% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
}

\newcommand{\cpp}{\textbf{C++}}

%% preamble
\title{Szablony w \cpp}
\author[]{Adrian Wysocki, Kamil Warchoł, Michał Szczepańczyk}
%\leftmark{The first author wants to thank someone.}

\begin{document}

%% title frame
\begin{frame}
\titlepage
\end{frame}
\author{}
%% normal frame
\begin{frame}{Szablony Wysockiego}
The body of the frame.
\end{frame}

\begin{frame}[fragile]{Typy domyślne}
    \begin{itemize}
        \item Typ w deklaracji typów szablonowych może mieć typ domyślny 
        \item Dotyczy to \textbf{tylko i wyłącznie} szablonów klas (do C++11)
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T = int>
class Collection {
    T * data;
public:
    explicit Collection(std::size_t size)
    : data(new T[size]) {}
    ...
};

Collection<double> double_col(20);
Collection<> def_col(30);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Typy domyślne - ograniczenia}
    \begin{itemize}
        \item Typy domyślne mogą zostać zadeklarowane tylko dla typów znajdujących się po prawej stronie -- analogicznie jak wartości domyślne w funkcjach
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename First, typename Second = double,
         typename Last>       // zle

template<typename First, typename Second = double,
         typename Last = int> // dobrze
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Parametry "nietypowe" -- non-type parameters}
    \begin{itemize}
        \item Parametrami szablonów nie muszą być typy, mogą być to również wartości całkowite
        \item Jednakże ich wartość musi być znana już podczas \textbf{kompilacji}
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T, std::size_t size>
class Collection {
    T data[size];
    ...
};

Collection<unsigned long, 10> col; // dobrze

int i = 20;
Collection<double, i> bad_col;     // zle
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Dozwolone typy}
    \begin{itemize}
        \item Dozwolonymi typami w nie-typowych parametrach są (opcjonalnie z kwalifikatorami cv):
        \begin{itemize}
            \item typy całkowite i wyliczeniowe (enum)
            \item wskaźnik do obiektu albo funkcji
            \item referencja do l-wartości
            \item wskaźnik do składnika klasy (w tym funkcji składowej)
            \item std::nullptr\_t
        \end{itemize}
    \end{itemize}
    \alert{Przykład 2.1}
\end{frame}

\begin{frame}[fragile]{Aliasy typów}
    \begin{itemize}
        \item Od standardu C++11 istnieje alternatywna składnia dla słowa kluczowego typedef
    \begin{lstlisting}[frame=single]
typedef std::vector<int, Alloc<int>> vec_int;
vec_int v;  // std::vector<int, Alloc<int>> v;

using vec_dbl = std::vector<double, Alloc<double>>;
vec_dbl vd; // std::vector<double, Alloc<double>> vd;
    \end{lstlisting}
        \item Ogólna składnia wygląda następująco:
\begin{lstlisting}[frame=single]
using alias_typu = nazwa_typu;
    \end{lstlisting}
    
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Aliasy szablonowe}
    \begin{itemize}
        \item Oprócz alternatywnej składni aliasy mogą być szablonowane
        \item Dzięki temu możemy stworzyć wygodne aliasy zależne od typu
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
using ptr = T*;

int x;
ptr<x> = &x;
ptr<const char> = "Hello, world!";
    \end{lstlisting}
    \alert{Przykład 2.2}
\end{frame}

\begin{frame}[fragile]{Zmienne szablonowe (C++14)}
    \begin{itemize}
        \item Przed standardem C++14 "zmienne szablonowe" były opakowywane w klasy
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
struct is_void {
    static constexpr bool value = ...;
};

std::cout << std::boolalpha << is_void<int>::value
          << std::endl;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Zmienne szablonowe}
    \begin{itemize}
        \item Wykorzystując zmienne szablonowe możemy uzyskać ten sam efekt pisząc mniej kodu
        \item Jest to tzw. "lukier składniowy" (syntactic sugar) - pod spodem wszystko działa jakby zmienna była statycznym polem klasy szablonowej
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
constexpr bool is_void_v = ...;

std::cout << std::boolalpha << is_void_v<int>
          << std::endl;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Typy stowarzyszone - cz. 1}
    \begin{itemize}
        \item W klasach i funkcjach szablonów możemy za pomocą typedef definiować również typy, nazywane stowarzyszonymi z daną klasą.
        \item Dzięki temu możemy odwoływać się do nich z innego miejsca
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T, int size>
class Stack {
    typedef T value_type;
    value_type x[size];
    ...
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Typy stowarzyszone - cz. 2}
    \begin{lstlisting}[frame=single,basicstyle=\small]
template<typename Container>
typename Container::value_type sum(Container s) {
    typename Container::value_type total = 0;
    
    for (int i = 0; i < s.size(); ++i)
        total += s[i];

    return total;
}
    \end{lstlisting}
    \begin{itemize}
        \item Słowo kluczowe \textbf{typename} jest tutaj wymagane, bez niego kompilator założyłby że Container::value\_type jest zmienną statyczną lub enumem.
        \item Bez typów stowarzyszonych musielibyśmy przekazać typ elementów kontenera w osobnym argumencie. Dlatego ten mechanizm jest bardzo czesto używany w uogólnionym kodzie.
    \end{itemize}
    \alert{Przykład 3.1} 
\end{frame}

\begin{frame}[fragile]{Type Traits - cechy typów}
    \begin{itemize}
     \item są to szablonowe metafunkcje, które zwracają informację o typie w czasie kompilacji
     \item są dostępne w bibliotece Boost C++, Loki oraz od standardu C++11 znajdują się również w pliku nagłówkowym \textbf{$<$type\_traits$>$} w bibliotece standardowej
     \item dostępne cechy można podzielić na:
      \begin{itemize}
       \item sprawdzające kategorie typów (is\_pointer, is\_enum)
       \item sprawdzające własności typów (is\_fundamental, is\_polymorphic)
       \item sprawdzające relacje między różnymi typami (is\_same, is\_convertible)
       \item modyfikujące typ (remove\_const, remove\_volatile, make\_unsigned)
       \item inne (enable\_if, conditional)
      \end{itemize}
    \item można również tworzyć własne cechy klas
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Jak tworzone są type traits?}
  \begin{itemize}
 \item Najczęściej:
 \begin{itemize}
 
 \item są zaimplementowane przez kompilator
  \item wykorzystują priorytetowość częściowych specjalizacji szablonów
  \item wykorzystują zjawisko SFINAE (Substitution Failure Is Not An Error)
 \end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Klasy cech - budowa}
    \begin{itemize}
     \item Przykładowa klasa type traits:
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
struct TypeTraits {
    typedef T type;
    const static bool isConst = false;
    enum {
        isPointer = false,
        isRef = false,
    };
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{std::integral\_constant - podstawowy type traits class}
    \begin{itemize}
     \item warto go zapamiętać, ponieważ jest on często wykorzystywany do implementacji wielu innych type traitsów
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T, T val>
struct integral_constant {
   static const T value = val;
   typedef T value_type;
   typedef integral_constant<T, val>  type;
   constexpr operator value_type() const noexcept { return value; }
};

/// Typ uzywany jako boolean (true) w czasie kompilacji
typedef integral_constant<bool, true>  true_type;
/// Typ uzywany jako boolean (false) w czasie kompilacji
typedef integral_constant<bool, false> false_type;

    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implementacja is\_reference - priorytetowość częściowych specjalizacji szablonów}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
#include <iostream>

template<typename T>
struct my_trait {
    static const bool isReference = false;
//    enum {isReference = false};
};

template<typename T>
struct my_trait<T &> {
    static const bool isReference = true;
//    enum {isReference = true};
};

int main() {
    std::cout << std::boolalpha;
    std::cout << my_trait<int &>::isReference << std::endl; // true
    std::cout << my_trait<int>::isReference << std::endl; // false
}
 \end{lstlisting}
\alert{Przykład 3.2}
\end{frame}

\begin{frame}[fragile]{Zastosowanie type traits 1 - warunkowa kompilacja}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
#include <type_traits>

template<typename T,
        typename= typename std::enable_if<std::is_enum<T>::value, void>::type>
void foo(T t) {}

enum Enum1 {A, B};
enum class Enum2 {C, D};

int main() {
    foo<>(A);
    foo(Enum2::C);
//    foo(1); // blad kompilacji - "no matching function for call to 'foo(int)'"
}
    \end{lstlisting}
    
    \alert{Przykład 3.3}
\end{frame}

\begin{frame}[fragile]{SFINAE - Substitution Failure Is Not An Error}
    \begin{lstlisting}[frame=single,basicstyle=\tiny]
struct Test {
    typedef int foo;
};

template <typename T> 
void f(typename T::foo) {} // Definicja #1

template <typename T> 
void f(T) {}               // Definicja #2

int main() {
    f<Test>(10); // Wywola #1.
    f<int>(10);  // Wywola #2.
}
    \end{lstlisting}
    
    \begin{itemize}
     \item kompilator wykonuje int::foo, co powoduje błąd kompilacji, jednak kompilacja nie jest przerywana dzięki SFINAE
    \end{itemize}

    \alert{Przykład 3.4}
\end{frame}

\begin{frame}[fragile]{Implementacja enable\_if - zastosowanie SFINAE}
    \begin{itemize}
        \item enable\_if może być używane na 3 sposoby w szablonach funkcji:
        \begin{itemize}
            \item jako typ zwracany zkonkretyzowanej funkcji
            \item jako dodatkowy parametr zkonkretyzowanej funkcji
            \item jako dodatkowy parametr szablonu
        \end{itemize} 
    \end{itemize}


    \begin{lstlisting}[frame=single,basicstyle=\tiny]
template <bool Condition, typename T = void>
struct enable_if {
    // Brak 'type', wiec proba uzycia spowoduje fail substitution
};

// czesciowa specjalizacja, kiedy Condition == true
template <typename T>
struct enable_if<true, T> {
    using type = T;
};
    \end{lstlisting}

    \alert{Przykład 3.5}
\end{frame}

\begin{frame}[fragile]{Zastosowanie type traits 2 - optymalizacja algorytmu}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
template<typename I1, typename I2, bool b>
I2 copy_imp(I1 first, I1 last, I2 out, const integral_constant<bool, b>&) {
   while(first != last) {
      *out = *first;
      ++out;
      ++first;
   }
   return out;
}

template<typename T>
T* copy_imp(const T* first, const T* last, T* out, const true_type&) {
   memmove(out, first, (last-first)*sizeof(T));
   return out+(last-first);
}

template<typename I1, typename I2>
I2 copy(I1 first, I1 last, I2 out) {
   //
   // We can copy with memcpy if T has a trivial assignment operator,
   // and if the iterator arguments are actually pointers (this last
   // requirement we detect with overload resolution):
   //
   typedef typename std::iterator_traits<I1>::value_type value_type;
   // If a type has a trivial assignment-operator then the operator has the same effect as copying the bits of one object to the other: calls to the operator can be safely replaced with a call to memcpy.
   return copy_imp(first, last, out, has_trivial_assign<value_type>());
}
    \end{lstlisting}
\end{frame}

\end{document}

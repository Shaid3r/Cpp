\documentclass[11pt]{beamer}

% options
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usetheme{Boadilla}
\usecolortheme{beaver}

\lstset{ %
language=C++,                % choose the language of the code
keywordstyle=\bfseries,
basicstyle=\color{black} \small,
stringstyle=\color{red}\ttfamily, % typewriter type for strings
showspaces=false,               % show spaces adding particular underscores
showstringspaces=true,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
tabsize=2,			% sets default tabsize to 2 spaces
captionpos=b,			% sets the caption-position to bottom
breaklines=true,		% sets automatic line breaking
breakatwhitespace=false,	% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
}

\newcommand{\cpp}{\textbf{C++}}

%% preamble
\title{Szablony w \cpp}
\author[]{Adrian Wysocki, Kamil Warchoł, Michał Szczepańczyk}
%\leftmark{The first author wants to thank someone.}

\begin{document}

%% title frame
\begin{frame}
\titlepage
\end{frame}
\author{}
%% normal frame
\begin{frame}{Szablony Wysockiego}
The body of the frame.
\end{frame}

\begin{frame}[fragile]{Typy domyślne}
    \begin{itemize}
        \item Typ w deklaracji typów szablonowych może mieć typ domyślny 
        \item Dotyczy to \textbf{tylko i wyłącznie} szablonów klas (do C++11)
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T = int>
class Collection {
    T * data;
public:
    explicit Collection(std::size_t size)
    : data(new T[size]) {}
    ...
};

Collection<double> double_col(20);
Collection<> def_col(30);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Typy domyślne - ograniczenia}
    \begin{itemize}
        \item Typy domyślne mogą zostać zadeklarowane tylko dla typów znajdujących się po prawej stronie -- analogicznie jak wartości domyślne w funkcjach
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename First, typename Second = double,
         typename Last>       // zle

template<typename First, typename Second = double,
         typename Last = int> // dobrze
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Parametry "nietypowe" -- non-type parameters}
    \begin{itemize}
        \item Parametrami szablonów nie muszą być typy, mogą być to również wartości całkowite
        \item Jednakże ich wartość musi być znana już podczas \textbf{kompilacji}
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T, std::size_t size>
class Collection {
    T data[size];
    ...
};

Collection<unsigned long, 10> col; // dobrze

int i = 20;
Collection<double, i> bad_col;     // zle
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Dozwolone typy}
    \begin{itemize}
        \item Dozwolonymi typami w poza-typowych parametrach są (opcjonalnie z kwalifikatorami cv):
        \begin{itemize}
            \item typy całkowite i wyliczeniowe (enum)
            \item wskaźnik do obiektu albo funkcji
            \item referencja do l-wartości
            \item wskaźnik do składnika klasy (w tym funkcji składowej)
            \item std::nullptr\_t
        \end{itemize}
    \end{itemize}
    \alert{Przykład 2.1}
\end{frame}

\begin{frame}[fragile]{Aliasy typów}
    \begin{itemize}
        \item Od standardu C++11 istnieje alternatywna składnia dla słowa kluczowego typedef
    \begin{lstlisting}[frame=single]
typedef std::vector<int, Alloc<int>> vec_int;
vec_int v;  // std::vector<int, Alloc<int>> v;

using vec_dbl = std::vector<double, Alloc<double>>;
vec_dbl vd; // std::vector<double, Alloc<double>> vd;
    \end{lstlisting}
        \item Ogólna składnia wygląda następująco:
\begin{lstlisting}[frame=single]
using alias_typu = nazwa_typu;
    \end{lstlisting}
    
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Aliasy szablonowe}
    \begin{itemize}
        \item Oprócz alternatywnej składni aliasy mogą być szablonowane
        \item Dzięki temu możemy stworzyć wygodne aliasy zależne od typu
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
using ptr = T*;

int x;
ptr<x> = &x;
ptr<const char> = "Hello, world!";
    \end{lstlisting}
    \alert{Przykład 2.2}
\end{frame}

\begin{frame}[fragile]{Zmienne szablonowe (C++14)}
    \begin{itemize}
        \item Przed standardem C++14 "zmienne szablonowe" były opakowywane w klasy
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
struct is_void {
    static constexpr bool value = ...;
};

std::cout << std::boolalpha << is_void<int>::value
          << std::endl;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Zmienne szablonowe}
    \begin{itemize}
        \item Wykorzystując zmienne szablonowe możemy uzyskać ten sam efekt pisząc mniej kodu
        \item Jest to tzw. "lukier składniowy" (syntactic sugar) - pod spodem wszystko działa jakby zmienna była statycznym polem klasy szablonowej
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
constexpr bool is_void_v = ...;

std::cout << std::boolalpha << is_void_v<int>
          << std::endl;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Variadic templates}
    \begin{itemize}
        \item Variadic templates to funkcje/klasy szablonowe przyjmujące zmienną liczbę argumentów
        \item Język C i C++ wspierał funkcje ze zmienną liczbą argumentów, chociażby printf()
        \item Funkcje takie były jednak niebezpieczne -- brak sprawdzania poprawności typów
        \item Od C++11 możliwe jest tworzenie funkcji szablonowych przyjmujących zmienną liczbę argumentów
        \item Dodatkowo typ każdego argumentu może być inny
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Variadic templates -- składania}
    \begin{itemize}
        \item Wielokropek określa paczkę parametrów
        \item Paczka parametrów może zawierać dowolną liczbę parametrów, włącznie z zerem
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename... Args>
void do_sth(Args... args) {
    ...
}

template <typename First, typename... Rest>
struct Tuple {
    ...
};

Tuple<int, double, std::string> three_elems;
Tuple<long> one_elem;
    \end{lstlisting}
    \alert{Przykład 2.3}
\end{frame}

\begin{frame}[fragile]{Variadic templates}
    \begin{itemize}
        \item Język nie posiada składni do rozpatrywania pojedynczych elementów z paczki parametrów
        \item Jednakże istnieje możliwość znalezienia liczby przesłanych parametrów za pomocą operatora sizeof...
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename... Args>
void variadic(Args... args) {
    std::cout << sizeof...(args) << std::endl;
}

variadic(1, 2, 3, 'a'); // wypisze 4
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Variadic templates -- rozpakowywanie}
    \begin{itemize}
        \item Wielokropek przed nazwą paczki rozpakowywuje parametry do listy oddzielonej przecinkiem
        \item Można to wykorzystać w kilku kontekstach
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename... Bases>
class Derived : public Bases... {
    Derived(const Bases&... bases) : Bases(bases)... {
    ...
    }
};

Derived<B1, B2, B3> derived1 { B1{}, B2{}, B3{} };
Derived<B4, B5>     derived2 { B4{}, B5{} };
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Variadic templates -- fold expressions}
    \begin{itemize}
        \item Istnieje możliwość utworzenia wyrażenia zawierającego wszystkie parametry
        \item Wymaganiem jednak jest posiadanie kompilatora wspierającago standard C++17
    \begin{lstlisting}[frame=single]
template <typename... Args>
auto expr(Args... args) {
    return ((2 * args) + ...);
    \end{lstlisting}
        \item W powyższym przykładzie wyrażenie zostanie rozwinięte do postaci\\(2 * arg1) + (2 * arg2) + (2 * arg3) + ...
    \end{itemize} 
    \alert{Przykład 2.4}
\end{frame}

\begin{frame}[fragile]{Fold expressions -- składnia}
    \begin{itemize}
        \item Składnia wygląda następująco:
        \begin{itemize}
            \item ( pack op ... )
            \item ( ... op pack )
            \item ( pack op ... op init)
            \item ( init op ... op pack )
        \end{itemize}
        \item Dozwolonymi operatorami są:
        \begin{itemize}
            \item dwuargumentowe operatory arytmetyczne
            \item dwuargumentowe operatory bitowe
            \item dwuargumentowe operatory relacyjne
            \item operator przecinek, .*, -\verb|>|*
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Variadic templates -- rekurencja}
    \begin{itemize}
        \item Aby wykonać bardziej skomplikowane operacje na każdym argumencie z osobna musimy wykorzystać rekurencję
        \item Oprócz tego funkcja powinna przyjmować co najmniej jeden argument niepochodzący z paczki argumentów
        \item Dodatkowo należy zapewnić warunek zatrzymania wywołań rekurencyjnych
        \item W tym celu stosuje się zwykłą, nieszablonową funkcję, która nie przyjmuje parametrów
    \end{itemize}
    \alert{Przykład 2.5}
\end{frame}

\begin{frame}[fragile]{Klasy parametryzowane wytycznymi}
    \begin{itemize}
        \item Klasy parametryzowane wytycznymi (policy classes) to technika konstruowania klas przy pomocy szablonów, dzięki której takie klasy mogą mieć dużo bardziej elastyczne wykorzystanie
        \item Wytyczne to nic innego jak klasy, które będą określać zachowanie klasy projektowanej
        \item Z tej techniki korzystają głównie twórcy bibliotek
        \item W bibliotece standardowej kolekcje są parametryzowane wytycznymi -- alokatory
    \end{itemize}
    \begin{lstlisting}[frame=single, basicstyle=\tiny]
template <typename T, typename ErrorHandling = NoChecking<T>>
class SmartPtr : public ErrorHandling {
    ...
};

SmartPtr<int> ptr1;
SmartPtr<int, StrictChecking<int>> ptr2;
    \end{lstlisting}
    \alert{Przykład 2.6}
\end{frame}

\begin{frame}[fragile]{Szablonowe parametry szablonów}
    \begin{itemize}
        \item W poprzednim przykładzie musieliśmy jawnie przekazać parametr do szablonu klasy ErrorHandling:
        \begin{lstlisting}[frame=single]
SmartPtr<int, StrictChecking<int>> ptr;
    \end{lstlisting}
        \item Nic nie stoi na przeszkodzie aby użytkownik podał drugi parametr w zły sposób:
        \begin{lstlisting}[frame=single]
SmartPtr<int, SomeOtherClass> ptr1;
SmartPtr<int, StrictChecking<double>> ptr2;
    \end{lstlisting}
        \item Z pomocą przychodzą nam szablonowe parametry szablonów
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Szablonowe parametry szablonów}
    \begin{itemize}
        \item Składnia szablonowych parametrów szablonów wygląda następująco (w zastosowaniu do naszego przykładu):
        \begin{lstlisting}[frame=single, basicstyle=\tiny]
template <typename T,
          template <typename U> class ErrorHandling = NoChecking>
class SmartPtr : public ErrorHandling<T> {
    ...
}

SmartPtr<int, SomeOtherClass> ptr1;         // blad kompilacji
SmartPtr<int, StrictChecking<double>> ptr2; // blad kompilacji
SmartPtr<int, StrictChecking<int>> ptr3;    // rowniez blad kompilacji
SmartPtr<int, StrictChecking> ptr4;         // OK
    \end{lstlisting}
        \item Dzięki takiemu podejściu oddelegowujemy odpowiedzialność za zgodność typów klasy SmartPtr z klasą wytyczną ErrorHandling do definicji klasy SmartPtr
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Szablonowe parametry szablonów -- pułapki}
    \begin{itemize}
        \item Należy jednak wziąc pod uwagę ważny aspekt -- ilość parametrów w szablonowym parametrze musi się zgadzać z ilością parametrów przyjmowanych przez dany szablon:
    \begin{lstlisting}[frame=single, basicstyle=\tiny]
template <typename T,
          template <typename> typename Collection> // C++17
class CollectionWrapper {
    Collection<T> col;
    ...
};

CollectionWrapper<int, std::vector> cw; // blad kompilacji,
                                        // std::vector oczekuje dwoch parametrow
    \end{lstlisting}
        \item Aby to poprawić należy dodać kolejny parametr:
    \begin{lstlisting}[frame=single, basicstyle=\tiny]
template <typename T,
          template <typename, typename> typename Collection>
class CollectionWrapper {
    Collection<T, std::allocator<T>> col;
    ...
};
    \end{lstlisting}   
    \end{itemize} 
\end{frame}


\begin{frame}[fragile]{Typy stowarzyszone - cz. 1}
    \begin{itemize}
        \item W klasach i funkcjach szablonów możemy za pomocą typedef definiować również typy, nazywane stowarzyszonymi z daną klasą.
        \item Dzięki temu możemy odwoływać się do nich z innego miejsca
    \end{itemize}
    \begin{lstlisting}[frame=single]
template<typename T, int size>
class Stack {
    typedef T value_type;
    value_type x[size];
    ...
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Typy stowarzyszone - cz. 2}
    \begin{lstlisting}[frame=single,basicstyle=\small]
template<typename Container>
typename Container::value_type sum(Container s) {
    typename Container::value_type total = 0;
    
    for (int i = 0; i < s.size(); ++i)
        total += s[i];

    return total;
}
    \end{lstlisting}
    \begin{itemize}
        \item Słowo kluczowe \textbf{typename} jest tutaj wymagane, bez niego kompilator założyłby że Container::value\_type jest zmienną statyczną lub enumem.
        \item Bez typów stowarzyszonych musielibyśmy przekazać typ elementów kontenera w osobnym argumencie. Dlatego ten mechanizm jest bardzo czesto używany w uogólnionym kodzie.
    \end{itemize}
    \alert{Przykład 3.1} 
\end{frame}

\begin{frame}[fragile]{Type Traits - cechy typów}
    \begin{itemize}
     \item są to szablonowe metafunkcje, które zwracają informację o typie w czasie kompilacji
     \item są dostępne w bibliotece Boost C++, Loki oraz od standardu C++11 znajdują się również w pliku nagłówkowym \textbf{$<$type\_traits$>$} w bibliotece standardowej
     \item dostępne cechy można podzielić na:
      \begin{itemize}
       \item sprawdzające kategorie typów (is\_pointer, is\_enum)
       \item sprawdzające własności typów (is\_fundamental, is\_polymorphic)
       \item sprawdzające relacje między różnymi typami (is\_same, is\_convertible)
       \item modyfikujące typ (remove\_const, remove\_volatile, make\_unsigned)
       \item inne (enable\_if, conditional)
      \end{itemize}
    \item można również tworzyć własne cechy klas
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Jak tworzone są type traits?}
  \begin{itemize}
 \item Najczęściej:
 \begin{itemize}
 
 \item są zaimplementowane przez kompilator
  \item wykorzystują priorytetowość częściowych specjalizacji szablonów
  \item wykorzystują zjawisko SFINAE (Substitution Failure Is Not An Error)
 \end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Klasy cech - budowa}
    \begin{itemize}
     \item Przykładowa klasa type traits:
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T>
struct TypeTraits {
    typedef T type;
    const static bool isConst = false;
    enum {
        isPointer = false,
        isRef = false,
    };
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{std::integral\_constant - podstawowy type traits class}
    \begin{itemize}
     \item warto go zapamiętać, ponieważ jest on często wykorzystywany do implementacji wielu innych type traitsów
    \end{itemize}
    \begin{lstlisting}[frame=single]
template <typename T, T val>
struct integral_constant {
   static const T value = val;
   typedef T value_type;
   typedef integral_constant<T, val>  type;
   constexpr operator value_type() const noexcept { return value; }
};

/// Typ uzywany jako boolean (true) w czasie kompilacji
typedef integral_constant<bool, true>  true_type;
/// Typ uzywany jako boolean (false) w czasie kompilacji
typedef integral_constant<bool, false> false_type;

    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implementacja is\_reference - priorytetowość częściowych specjalizacji szablonów}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
#include <iostream>

template<typename T>
struct my_trait {
    static const bool isReference = false;
//    enum {isReference = false};
};

template<typename T>
struct my_trait<T &> {
    static const bool isReference = true;
//    enum {isReference = true};
};

int main() {
    std::cout << std::boolalpha;
    std::cout << my_trait<int &>::isReference << std::endl; // true
    std::cout << my_trait<int>::isReference << std::endl; // false
}
 \end{lstlisting}
\alert{Przykład 3.2}
\end{frame}

\begin{frame}[fragile]{Zastosowanie type traits 1 - warunkowa kompilacja}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
#include <type_traits>

template<typename T,
        typename= typename std::enable_if<std::is_enum<T>::value, void>::type>
void foo(T t) {}

enum Enum1 {A, B};
enum class Enum2 {C, D};

int main() {
    foo<>(A);
    foo(Enum2::C);
//    foo(1); // blad kompilacji - "no matching function for call to 'foo(int)'"
}
    \end{lstlisting}
    
    \alert{Przykład 3.3}
\end{frame}

\begin{frame}[fragile]{SFINAE - Substitution Failure Is Not An Error}
    \begin{lstlisting}[frame=single,basicstyle=\tiny]
struct Test {
    typedef int foo;
};

template <typename T> 
void f(typename T::foo) {} // Definicja #1

template <typename T> 
void f(T) {}               // Definicja #2

int main() {
    f<Test>(10); // Wywola #1.
    f<int>(10);  // Wywola #2.
}
    \end{lstlisting}
    
    \begin{itemize}
     \item kompilator wykonuje int::foo, co powoduje błąd kompilacji, jednak kompilacja nie jest przerywana dzięki SFINAE
    \end{itemize}

    \alert{Przykład 3.4}
\end{frame}

\begin{frame}[fragile]{Implementacja enable\_if - zastosowanie SFINAE}
    \begin{itemize}
        \item enable\_if może być używane na 3 sposoby w szablonach funkcji:
        \begin{itemize}
            \item jako typ zwracany zkonkretyzowanej funkcji
            \item jako dodatkowy parametr zkonkretyzowanej funkcji
            \item jako dodatkowy parametr szablonu
        \end{itemize} 
    \end{itemize}


    \begin{lstlisting}[frame=single,basicstyle=\tiny]
template <bool Condition, typename T = void>
struct enable_if {
    // Brak 'type', wiec proba uzycia spowoduje fail substitution
};

// czesciowa specjalizacja, kiedy Condition == true
template <typename T>
struct enable_if<true, T> {
    using type = T;
};
    \end{lstlisting}

    \alert{Przykład 3.5}
\end{frame}

\begin{frame}[fragile]{Zastosowanie type traits 2 - optymalizacja algorytmu}
 \begin{lstlisting}[frame=single,basicstyle=\tiny]
template<typename I1, typename I2, bool b>
I2 copy_imp(I1 first, I1 last, I2 out, const integral_constant<bool, b>&) {
   while(first != last) {
      *out = *first;
      ++out;
      ++first;
   }
   return out;
}

template<typename T>
T* copy_imp(const T* first, const T* last, T* out, const true_type&) {
   memmove(out, first, (last-first)*sizeof(T));
   return out+(last-first);
}

template<typename I1, typename I2>
I2 copy(I1 first, I1 last, I2 out) {
   //
   // We can copy with memcpy if T has a trivial assignment operator,
   // and if the iterator arguments are actually pointers (this last
   // requirement we detect with overload resolution):
   //
   typedef typename std::iterator_traits<I1>::value_type value_type;
   // If a type has a trivial assignment-operator then the operator has the same effect as copying the bits of one object to the other: calls to the operator can be safely replaced with a call to memcpy.
   return copy_imp(first, last, out, has_trivial_assign<value_type>());
}
    \end{lstlisting}
\end{frame}

\end{document}
